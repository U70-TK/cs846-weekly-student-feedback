# Week 6 Feedback: Code Generation

**Authors:** [Neel Sanjaybhai Faganiya, Ibrahim Mohammed Sayem, Felix Wang]

## 1. Counterexample Problems

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example

Find the related files in the `Week6` folder.

## Example Problems

### Problem A: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:**

You are given a list of dictionaries representing sales transactions. Each transaction contains:
- `"product"`: a string product name
- `"quantity"`: a positive integer
- `"price"`: a positive float

Write a Python function `calculate_total_revenue(transactions)` that:
1. Validates that transactions is a non-empty list
2. Validates each transaction has the required keys and valid values
3. Returns the total revenue (sum of quantity × price for all transactions)
4. Raises a `ValueError` with a descriptive message if validation fails

**Example input:**
```python
transactions = [
    {"product": "Widget A", "quantity": 5, "price": 10.50},
    {"product": "Widget B", "quantity": 3, "price": 15.00},
    {"product": "Widget C", "quantity": 2, "price": 8.75}
]
```

**Expected output:** `115.0` (5×10.50 + 3×15.00 + 2×8.75 = 52.5 + 45 + 17.5)

**Starter Code:**

The code for this task and its related files can be found in the `artifacts` folder. The starter code is located at `artifacts/calc_rev.py`.


---

### Problem B: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example

**Model To Use:**
GPT-4.1

**Task Description:**

In this task, you are required to implement a calculator backend in Python-Flask with the help of coding agents. The backend server, named MyCalculator is designed to perform simple arithmetic calculations based on user input. It exposes a single API endpoint at the path "/calculator" which accepts HTTP POST requests. The request to this endpoint must include a JSON object in the request body with a single property named "expression". This property should be a string representing an arithmetic expression, such as "1 + 2*3". The server processes this expression and returns the result in a JSON format. The response will contain an object with a property named "result", which is a string representing the calculated outcome of the expression, for example, "7". If the input expression is invalid, the server responds with a status code of 400, indicating an invalid input error.

Only these packages are allowed: 

```
itsdangerous==2.2.0
blinker==1.9.0
click==8.1.7
Flask==3.1.0
Jinja2==3.1.4
MarkupSafe==3.0.2
Werkzeug==3.1.3
passlib==1.7.4
fpdf==1.7.2
pyjwt==2.10.1
```

You task is to let the LLM generate high-quality backend code fulfilling the requirements. The prompts before using the guideline and after using the guideline are already provided. Please only use **GPT-4.1** for this task for reproducibility. 

1. Please let the LLM generate code for **5 times** using prompts from `artifacts/Problem_B/prompt_before.txt`, with each time opening a **new chat**. 
2. Run all functional tests at `artifacts/Problem_B/tests` to evaluate the functionality of `app.py`.
3. Run all security tests at `artifacts/Problem_B/hidden_tests` to evaluate the security vulnerability of `app.py`. 
4. Repeat the procedure from 1-3, this time using prompt from `artifacts/Problem_B/prompt_after.txt`. 

**Starter Code:**
The code related to this task and all related files can be found in the `artifacts/Problem_B` folder. The starter code is at `artifacts/Problem_B/app.py`. 

---

### Problem C: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example

**Task folder:** Please find the starter code in the folder 

**Task Description:**

**Student Tasks:**

---

### 2. Guidelines that didn't work

---

#### Guideline 3: Specify required external libraries/packages and their purpose.

**Prompt and Context:**

```
Solve the calculate_total_revenue problem in `artifacts/calc_rev.py`. You must use pandas for data manipulation 
and numpy for numerical operations. Use pandas DataFrame to validate and process the 
transactions. Run the test command: python3 -m unittest tests.test_revenue
```
You should pass all the tests.

**Task:**

Write a Python function `calculate_total_revenue(transactions)` that:
1. Validates that transactions is a non-empty list
2. Validates each transaction has the required keys and valid values
3. Returns the total revenue (sum of quantity × price for all transactions)
4. Raises a `ValueError` with a descriptive message if validation fails

**Solution or Output generated by Github Copilot:**

```python
import pandas as pd
import numpy as np

def calculate_total_revenue(transactions):
    """
    Calculate total revenue from a list of transaction dictionaries using pandas and numpy.
    
    Args:
        transactions: A list of dictionaries, each containing:
            - "product": a string product name (non-empty)
            - "quantity": a positive integer
            - "price": a positive float
    
    Returns:
        float: Total revenue (sum of quantity × price for all transactions)
    
    Raises:
        ValueError: If validation fails with a descriptive message
    """
    # Validate input
    if transactions is None:
        raise ValueError("transactions cannot be None")
    if not isinstance(transactions, list):
        raise ValueError("transactions must be a list")
    if len(transactions) == 0:
        raise ValueError("transactions cannot be empty")
    
    # Convert to DataFrame
    try:
        df = pd.DataFrame(transactions)
    except Exception as e:
        raise ValueError(f"Failed to create DataFrame from transactions: {e}")
    
    # Check required columns
    required_cols = {"product", "quantity", "price"}
    if not required_cols.issubset(df.columns):
        missing = required_cols - set(df.columns)
        raise ValueError(f"transactions missing required keys: {missing}")
    
    # Validate product: non-empty string
    if not df['product'].apply(lambda x: isinstance(x, str) and x.strip()).all():
        raise ValueError("All products must be non-empty strings")
    
    # Validate quantity: positive integer
    if not df['quantity'].apply(lambda x: isinstance(x, int) and x > 0).all():
        raise ValueError("All quantities must be positive integers")
    
    # Validate price: positive number
    if not df['price'].apply(lambda x: isinstance(x, (int, float)) and x > 0 and not np.isnan(x)).all():
        raise ValueError("All prices must be positive numbers")
    
    # Compute total revenue using numpy for numerical operations
    quantities = df['quantity'].values  # numpy array
    prices = df['price'].values  # numpy array
    revenues = np.multiply(quantities, prices)
    total = np.sum(revenues)
    
    return total

```

**Why this is bad:**
- **Over-engineered**: Uses pandas DataFrame for a simple list of dictionaries
- **Heavy dependencies**: Requires pandas and numpy for a trivial calculation
- **Performance overhead**: DataFrame creation and operations are slower than simple loops
- **Complexity**: More code, more potential failure points
- **Dependency issues**: May fail if pandas/numpy aren't installed or have version conflicts
- **Unnecessary abstraction**: The problem doesn't require tabular data operations

---

#### Guideline : 

**Prompt and Context:** 

**Task:**

**Solution or Output generated by Github Copilot:**


---

#### Guideline : 

**Prompt and Context:**  

**Task:** 

**Solution or Output generated by GitHub Copilot:**


...

---

### 3. New and Updated Guidelines that worked

#### Guideline 1: Prefer Built-in Solutions When Appropriate

**Description:**
Before specifying external libraries, evaluate whether the problem can be solved efficiently with Python's built-in functions and standard library. Only specify external libraries when:
1. The problem genuinely requires specialized functionality (e.g., machine learning, advanced data structures)
2. The library provides significant performance benefits for the problem size
3. The library is already a project dependency
4. The problem explicitly requires using a specific library (e.g., for learning purposes)

**Reasoning:**
Over-specifying libraries can lead to:
- Unnecessary complexity for simple problems
- Additional dependency management overhead
- Performance degradation for small datasets
- Increased risk of dependency conflicts
- Code that's harder to understand and maintain

**Prompt and Context:** 

```
Solve the calculate_total_revenue problem. Use only Python built-in functions and
standard library. Keep the solution simple and efficient. Run the test command:
python3 -m unittest tests.test_revenue.
```
You should pass all the tests.

**Task:**

Write a Python function `calculate_total_revenue(transactions)` that:
1. Validates that transactions is a non-empty list
2. Validates each transaction has the required keys and valid values
3. Returns the total revenue (sum of quantity × price for all transactions)
4. Raises a `ValueError` with a descriptive message if validation fails

**Solution or Output generated by Github Copilot:**

```python
import math

def calculate_total_revenue(transactions):
    """
    Calculate total revenue from a list of transaction dictionaries.
    
    Args:
        transactions: A list of dictionaries, each containing:
            - "product": a string product name (non-empty)
            - "quantity": a positive integer
            - "price": a positive float
    
    Returns:
        float: Total revenue (sum of quantity × price for all transactions)
    
    Raises:
        ValueError: If validation fails with a descriptive message
    """
    # Validate input
    if transactions is None:
        raise ValueError("transactions cannot be None")
    if not isinstance(transactions, list):
        raise ValueError("transactions must be a list")
    if len(transactions) == 0:
        raise ValueError("transactions cannot be empty")
    
    total = 0.0
    for i, transaction in enumerate(transactions):
        if not isinstance(transaction, dict):
            raise ValueError(f"Transaction {i} must be a dictionary")
        
        # Check required keys
        required_keys = {"product", "quantity", "price"}
        if not required_keys.issubset(transaction.keys()):
            missing = required_keys - set(transaction.keys())
            raise ValueError(f"Transaction {i} missing required keys: {missing}")
        
        product = transaction["product"]
        quantity = transaction["quantity"]
        price = transaction["price"]
        
        # Validate product
        if not isinstance(product, str) or not product.strip():
            raise ValueError(f"Transaction {i}: product must be a non-empty string")
        
        # Validate quantity
        if not isinstance(quantity, int) or quantity <= 0:
            raise ValueError(f"Transaction {i}: quantity must be a positive integer")
        
        # Validate price
        if not isinstance(price, (int, float)) or price <= 0 or (isinstance(price, float) and math.isnan(price)):
            raise ValueError(f"Transaction {i}: price must be a positive number")
        
        # Add to total
        total += quantity * price
    
    return total
```

**Why is this better:**
- **Simple and direct**: Uses only built-in Python features
- **No dependencies**: Works in any Python environment
- **Better performance**: Direct iteration is faster than DataFrame operations
- **Clearer code**: Easier to read and understand
- **Fewer failure points**: Less code, fewer things that can go wrong
- **Appropriate complexity**: Matches the problem's complexity level

---

#### Guideline 2: 

**Prompt and Context:**

**Task:**

**Solution or Output generated by Github Copilot:**

---

#### Guideline 3: 

**Prompt and Context:**

**Task:** 

**Solution or Output generated by GitHub Copilot:**

...

---
