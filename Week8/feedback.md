# Week 8 Feedback: DevReview/Debug

**Authors:** [Neel Sanjaybhai Faganiya, Ibrahim Mohammed Sayem, Felix Wang]

## 1. Counterexample Problems

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example

Find the related files in the `Week8` folder.

## Example Problems

### Problem A: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:** 

You are given a small Flask app (entry point `app.py`, webhook handler in `webhook/views.py`). The app returns 500 when `POST /webhook` is called with a JSON body that omits the `source` field (e.g., `curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'`), raising `TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'`. Your task is to localize the bug and fix the code so that requests with or without `source` are handled without raising this error.

**Starter Code:**

The code for this task and its related files can be found in the `artifacts/Problem_A` folder. The code is located at `artifacts/Problem_A/app.py` and `artifacts/Problem_A/webhook/`.

---

### Problem B: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:**

**Starter Code:**

---

### Problem C: 
You are given a small Python reporting pipeline used by a public library to track book inventory and member checkouts. The system loads data from two CSV files (`books.csv`, `checkouts.csv`), derives key metrics, and produces three JSON
reports consumed by the library's front-desk dashboard.

The pipeline consists of two modules driven by `main.py`:

```
Stage 1 → tracker/loader.py - Ingest CSV files; derive computed fields per record
Stage 2 → tracker/reports.py  - Compute late fees, genre availability, top books
```

Input data in `data/`: [All the generated using ChatGPT]

| File | Contents |
|---|---|
| `data/books.csv` | 10 books across 7 genres with copy counts |
| `data/checkouts.csv` | 12 checkout records with dates, return status, and fee rate |

---

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:**

**Student Tasks:**

---

### 2. Guidelines that didn't work

---

#### Guideline 7 : Instruct the agent to trace from the entry point of your program.

**Prompt and Context:** 

**Prompt:**
My Flask app sometimes returns 500 when posting to /webhook. The exception is:
"TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'"

Fix the code. Step through the program starting at the entry point (app.py, 
where the Flask app is created and run). Keep edge cases in mind.

**Context:**
The repo is in `Week8/artifacts/Problem_A` and contains:
- `app.py` – creates the Flask app, registers blueprints, and has `if __name__ == '__main__': app.run(...)`.
- `webhook/views.py` – defines the `/webhook` route and handler where the bug actually is (concatenating `source`, which can be `None` when the key is missing, with a string).

**Task:**  

The task is to fix the code so that when a ping request is sent (e.g., `curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'`), the `500` error is eliminated and the ping request succeeds.

*How to reproduce the error:* 

From the repo root run `pip install -r requirements.txt` then `python app.py`. In another terminal:
```bash
curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'
```
The request omits `source`, so `data.get("source")` is `None` and the line `log_message = source + ": " + ...` raises `TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'`.

**Solution or Output generated by Github Copilot:**

**What we observed:** When we used the same prompt (with “step through starting at the entry point (app.py)”) in **VS Code Copilot**, Copilot still located the bug in `webhook/views.py` and fixed it. So the guideline does not *guarantee* failure—models may search by route name, exception text, or codebase structure and find the handler anyway. The counter-example’s point is that **Guideline 7 is suboptimal** for this class of bug: tracing from the entry point does not naturally point at the failing request path, so the model may take more steps, consider edits in `app.py` first, or depend on ignoring the instruction. The counter-guideline (“trace from the failure trigger”) is still preferable because it targets the right code path from the start.

**What goes wrong:**

1. **Bug is not on the path from the entry point.**  
   The entry point is `app.run()` in `app.py`. Tracing from there goes through app creation, route registration, and then the server loop. The failing code runs only when a **request** hits `/webhook`; that path is triggered by an external HTTP call, not by the initial execution from `main`. So “trace from entry point” never naturally leads the model into `webhook/views.py` where the bug is.

2. **Model is steered toward the wrong place.**  
   The guideline encourages a linear trace from `app.py`. The model may spend time analyzing `app.py`, config, and startup code, and may propose changes there (e.g. middleware, error handlers) instead of locating the actual bug in the webhook handler.

3. **Entry point is misleading for request-driven behavior.**  
   In request/response or event-driven apps, the “execution path” that matters for a given bug is the **request path** (e.g. HTTP request → routing → handler), not the process startup path. Tying the debugging strategy to “start at main” fits batch/script-style programs, not this scenario.

The model may never focus on the handler where `None + str` happens, may suggest fixes in the wrong file, or take many turns before reaching the right place. So **Guideline 7, as applied here, does not work as intended** for this question.


---

#### Guideline : 

**Prompt and Context:** 

**Task:**

**Solution or Output generated by Github Copilot:**


---

#### Guideline : 

**Prompt and Context:**  

**Task:** 

**Solution or Output generated by GitHub Copilot:**


...

---

### 3. New and Updated Guidelines that worked

#### Guideline 1: Trace from the failure trigger

**Description:**  
For request-driven, event-driven, or callback-based programs, instruct the model to start from the **point that triggers the failure** (e.g. the route, event handler, or callback), not from the process entry point. Specify the trigger when you know it (e.g. “when POST /webhook is called” or “when this button is clicked”).

**Reasoning:**  
Many bugs only occur on paths that are not the main thread of execution from `main()`. Tracing from the failure trigger (the route, the handler, the callback) aligns the model’s search with the execution path that actually runs when the error happens, so it can localize and fix the bug in fewer steps.

**Prompt and Context:** 

**Prompt:**

```
My Flask app sometimes returns 500 when posting to /webhook. The exception is:
"TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'"

Fix the code. Start from the code that runs when a POST request hits /webhook 
(i.e. the webhook route handler) and trace from there. Keep edge cases in mind.
```

**Context:**

The repo is in `Week8/artifacts/Problem_A` and contains:
- `app.py` – creates the Flask app, registers blueprints, and has `if __name__ == '__main__': app.run(...)`.
- `webhook/views.py` – defines the `/webhook` route and handler where the bug actually is (concatenating `source`, which can be `None` when the key is missing, with a string).

**Task:** 

You are given a small Flask app (entry point `app.py`, webhook handler in `webhook/views.py`). The app returns 500 when `POST /webhook` is called with a JSON body that omits the `source` field (e.g., `curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'`), raising `TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'`. Your task is to localize the bug and fix the code so that requests with or without `source` are handled without raising this error.

**Solution or Output generated by Github Copilot:**

**What we observed:** When we used the updated guideline (“trace from the failure trigger”) in **VS Code Copilot**, Copilot located the bug in `webhook/views.py` and fixed it reliably and in fewer steps. Starting from the failing request path (e.g., the webhook route and the exception) led the model directly to the handler and the faulty code, without extra exploration in `app.py` or reliance on route-name or exception-text search. **Guideline 7 (trace from the entry point)** is suboptimal for this class of bug because it does not naturally point at the failing path; the counter-guideline (“trace from the failure trigger”) is preferable and worked well with fewer steps.

**Why is this better?**

The model is instructed to start at the **failure trigger** (the `/webhook` handler) rather than at the process entry point (`app.py`). So it goes straight to the handler code, finds the line that causes `None + str`, and can fix it (e.g. by handling `None` or using a default) in fewer steps. By contrast, tracing from the entry point would have the model step through app creation, blueprint registration, and routing before reaching the handler—so localization takes longer and the model may consider edits in `app.py` first. Anchoring on the trigger (route + exception message) aligns the search with the execution path that actually fails, which is why this guideline works better for request- or event-driven bugs.


---

#### Guideline 2: 

**Prompt and Context:**

**Task:**

**Solution or Output generated by Github Copilot:**

---

#### Guideline 3: 

**Prompt and Context:**

**Task:** 

**Solution or Output generated by GitHub Copilot:**

...

---

## References

[1] Sharma, Mrinank, et al. "Towards Understanding Sycophancy in Language Models." The Twelfth International Conference on Learning Representations. 2024.