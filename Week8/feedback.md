# Week 8 Feedback: DevReview/Debug

**Authors:** [Neel Sanjaybhai Faganiya, Ibrahim Mohammed Sayem, Felix Wang]

## 1. Counterexample Problems

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example

Find the related files in the `Week8` folder.

## Example Problems

### Problem A: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:** 

You are given a small Flask app (entry point `app.py`, webhook handler in `webhook/views.py`). The app returns 500 when `POST /webhook` is called with a JSON body that omits the `source` field (e.g., `curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'`), raising `TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'`. Your task is to localize the bug and fix the code so that requests with or without `source` are handled without raising this error.

**Starter Code:**

The code for this task and its related files can be found in the `artifacts/Problem_A` folder. The code is located at `artifacts/Problem_A/app.py` and `artifacts/Problem_A/webhook/`.

---

### Problem B: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:**

**Starter Code:**

---

### Problem C: 

**Github repository URL:** https://github.com/U70-TK/cs846-requirement-example


**Task Description:**

**Student Tasks:**

---

### 2. Guidelines that didn't work

---

#### Guideline 7 : Instruct the agent to trace from the entry point of your program.

**Prompt and Context:** 

**Prompt:**
My Flask app sometimes returns 500 when posting to /webhook. The exception is:
"TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'"

Fix the code. Step through the program starting at the entry point (app.py, 
where the Flask app is created and run). Keep edge cases in mind.

**Context:**
The repo is in `Week8/artifacts/Problem_A` and contains:
- `app.py` – creates the Flask app, registers blueprints, and has `if __name__ == '__main__': app.run(...)`.
- `webhook/views.py` – defines the `/webhook` route and handler where the bug actually is (concatenating `source`, which can be `None` when the key is missing, with a string).

**Task:**  

The task is to fix the code so that when a ping request is sent (e.g., `curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'`), the `500` error is eliminated and the ping request succeeds.

*How to reproduce the error:* 

From the repo root run `pip install -r requirements.txt` then `python app.py`. In another terminal:
```bash
curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "ping"}'
```
The request omits `source`, so `data.get("source")` is `None` and the line `log_message = source + ": " + ...` raises `TypeError: unsupported operand type(s) for +: 'NoneType' and 'str'`.

**Solution or Output generated by Github Copilot:**

**What we observed:** When we used the same prompt (with “step through starting at the entry point (app.py)”) in **VS Code Copilot**, Copilot still located the bug in `webhook/views.py` and fixed it. So the guideline does not *guarantee* failure—models may search by route name, exception text, or codebase structure and find the handler anyway. The counter-example’s point is that **Guideline 7 is suboptimal** for this class of bug: tracing from the entry point does not naturally point at the failing request path, so the model may take more steps, consider edits in `app.py` first, or depend on ignoring the instruction. The counter-guideline (“trace from the failure trigger”) is still preferable because it targets the right code path from the start.

**What goes wrong:**

1. **Bug is not on the path from the entry point.**  
   The entry point is `app.run()` in `app.py`. Tracing from there goes through app creation, route registration, and then the server loop. The failing code runs only when a **request** hits `/webhook`; that path is triggered by an external HTTP call, not by the initial execution from `main`. So “trace from entry point” never naturally leads the model into `webhook/views.py` where the bug is.

2. **Model is steered toward the wrong place.**  
   The guideline encourages a linear trace from `app.py`. The model may spend time analyzing `app.py`, config, and startup code, and may propose changes there (e.g. middleware, error handlers) instead of locating the actual bug in the webhook handler.

3. **Entry point is misleading for request-driven behavior.**  
   In request/response or event-driven apps, the “execution path” that matters for a given bug is the **request path** (e.g. HTTP request → routing → handler), not the process startup path. Tying the debugging strategy to “start at main” fits batch/script-style programs, not this scenario.

The model may never focus on the handler where `None + str` happens, may suggest fixes in the wrong file, or take many turns before reaching the right place. So **Guideline 7, as applied here, does not work as intended** for this question.


---

#### Guideline : 

**Prompt and Context:** 

**Task:**

**Solution or Output generated by Github Copilot:**


---

#### Guideline : 

**Prompt and Context:**  

**Task:** 

**Solution or Output generated by GitHub Copilot:**


...

---

### 3. New and Updated Guidelines that worked

#### Guideline 1:

**Prompt and Context:** 

**Task:** 

**Solution or Output generated by Github Copilot:**


---

#### Guideline 2: 

**Prompt and Context:**

**Task:**

**Solution or Output generated by Github Copilot:**

---

#### Guideline 3: 

**Prompt and Context:**

**Task:** 

**Solution or Output generated by GitHub Copilot:**

...

---

